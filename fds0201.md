# Control Flow (0201) 

## Control Flow|10:26~11:07

For (var i = 0; i < 10; i ++ ) {

​	if (i  % 2)  {

​		console.log(i);

​	}

}

> 신생언어들은 정적언어를 지원하는 추세지만, 대부분의 언어는 정적 타입이 아니다.

`Concatenation`

`concat : 1) 문자열을 이어준다는 의미로 사용된다. f(concat) 의미한다.`



메모리는 운영체제가 할당한다 브라우져가 중계자 역할을 한다.

가비지 컬렉터는 브라우져 내부에서 작동하는 역할을 한다.



눈코딩후 예측과 다를 경우에, 원인을 찾아야 한다.

코딩을 잘못했거나

문법을 잘못알고있거나

Technical Debt(기술 부채)

기술부채를 해결해야 한다.



중복을 싫어하는 이유 

유지보수 비용이 늘어난다.

효율성이 늘어난다.

---

## Control Flow|11:17-11:50

> 자바스크립트 동적할당 언어

> 조건식은 논리값으로 평가되어야한다.

> 조건식은 표현식의 일종이다.

> 연산자와 피연산자로 구성된다. 



가장기본은 트루티 밸류 폴스 밸류 부정적인 것은 대부분 뽈스로 간주한다

빈 문자 숫자 영 언디파인드 널 

자바스크립트는 암묵적 강제 형변환을 통해 조건식을 평가한다.



if (null) {
  console.log('4');
}

평가후, 폴스로 간주하여 실행이 안된다.



parseInt 문자를 정수로 변환해준다.

 immutable 하다, pass-by-value



생성자 함수는 , 자바의 클래스 같은 것.

생성자 함수는 뉴 연산자와 함께 사용한다

컨스트럭트를 ㅅ함게사용하면 인스트럭트가 생성된다

자바는 생성자 함수와 뉴 인스턴스를 생성하면 실제의 인스턴스가 ㅅ나등ㄹ저ㅣ 지는데 뉴를 붙이지 않고 사용하면 형 변환이 일어난다.





본래의 취지에서 어긋나는 것들을 권장하지 않는다.

스트링이라는 생성자는 스트링 객체를 생성한다 기본자료형이 아닌 스트링 객체를 생성한다.

넘버 객체를 만든다

불리언 객체를 만든다.

이런 방법이 있다는 사실을 일단 알아두시고요

이 플러스는 좌항과 우항에 연상자가 있어야 한다.

단항연산자는  양수 음수 표기를 위해 사용한다. 



+10 은 10을 양수화한다는 의미이다.

비트연산을 한다. 



결과론 적으로는 차이가 없다.

추측 스펙 브라우져마다 저마다 다르다.



단항연산자를 붙이면 뒤에 있는 값을 양수화하기 위해서 컨버전한다.

언디파인트와 난은 컨버전 할 수 없다.



기억할것!!!

스트링을 넘버로

넘버를 스트링으로 변환하는 일이 많다

스트링을 넘버로 변환할때는 단항 연산자를 사용한다.

*1을 사용한다. 



+1 이나 parseInt	를 사용해 스트링을 넘버로 변환하도록 한다.



Val = val + ''; 

toSrting



----

4.6

Html 상에 있는 요소를 가지고 온다 아이디를 조건으로 html요소를 가지고온다. 



코딩할때 이게 지정한 값이 불러오는 값이 없으면 어떻게 하지? 라는 사항을 고려해야한다.



실무에서는 에러 처리를 꼼꼼하게 해야한다.



if(elem)

if(elem=true)는 다르다

---

## 12:02

1 week Javascript Fundamentals

타이핑

정보 및 자료수집 후 정리



## 1. Object 란?

서브젝트 주어



주체와 객체



인식가능한 모든 것은 객체이다.



인문학에 있는 사상이나 개념들이 컴퓨터 공학에 녹아들어있습니다.

철학적 개념들이 컴퓨터 내부에 있습니다

사람은 사람을 어ㄸ허게 인식하느냐에서 컴퓨터 공학에 객체라는 개념이 들어오게 되었다



어떠한 사물은 사물을 가르키는 속성이 있다. 

데이터적 성질 용량 부피 길이 면적 색상

데이터적 성격을 가지고 있다

동작을 가지고 있다.





이름 나이 성별 주소 

동작 동사



우리는 사물을 속성을 가지고 인식한다 인지한다.

그속성들은 대부분 명사적 특징과 동사적 특징으로 나뉜다



동사적 특징을 메소드

명사적 특징을 함수라고 한다.



property : 라는 이름이 있다. 

Var person = {

property name: 'lee', 

age: 20, 

ect;

}



추상화

객체 지향의 가장 중요한 것은 추상화이다. 

우리가 관심있는 대상들만 표현한다.



메소드

Speak:function(){

}

메소드의 값은 대부분 데이터에 대한 동작을 의미한다.

항상 명사는 주어 또는 ㅗㅁㄱ적어로 사용된다 프로퍼티는 목적어 

메소드는 목적어를 받는 술어의 역할을 수행한다.



---



이웅모 공부방법, 기존에 가지고 있는 지식을 기반으로 새로운 지식과의 연관성을 찾아서 

지식을 학습한다.



---

객체지향은 무엇인가? 

객체는 데이터와 그 데이터에 관련되는 절차 방법 기능 을 모두 포함할 수 있는 개념적 존재이다 달리 말해 이름키과 값으로 구성된 데이터를 의미하는 프로퍼티와 동작을 나타내는 메소드를 포함고 있느 독립적 주체이다



정보은닉:

다형성:



상속: 실제 가족관계

HTML 콘텐츠안에 위치하면 상속된다





프로토타입은 상속을 표현하는 개념이다.



클래스와 클래스 간에 관계를 맺어준다.

---

프로토타입은 상속을 표현하는 개념이다

상속의 관점에서 프로토타입에 접근하자

부모의 자원은 내것이다

부모도 하나의 객체이다.

부모의 자원은 프로퍼티와 메소드이다.

---

프로퍼티 이름은 빈문자열을 포함하는 문자열과 숫자 (문자열로 간주해준다. 정석은 ""를 사용하는게 옳으나 편의상 생략가능하다)



Key:= name:= value



프라퍼티는 변수ㅘ 비슷하다. 그 값은 우리가 알고 있는 언디파인드를 제외한 모든 자료형이 가능하다.



object 



함수는 객체이다. 

객체는 함수가 아니다.

함수가 객체라는 특징이 자바스크립트의 장점이다.



객체는 메소스를 소유한다. 리소스이다.??



메소드는 함수이다. 객체 내에 있는함수를 메소드이다.

댓글은 빨리 많이 치는 사람이 이긴다.



빈객체도 존제한다.

2. 객체 생성방법

객체 리터럴 {프로퍼티 이름 프로퍼티 값}을 입력해 객체를 생성한다.)



비었지만 실체가 있기 때문에 트루값으로 반환한다.



객체 리터럴에 의한 생성방식 

데이터를 상위에 

메소드를 아래에 입력한다. 관습이다.

객체리터럴을 자바스크립트의 꼬이라고 생각한다.



표현과 동시에 표현이 끝남과 동시에 할당되고 생성된다.



문법적 설탕 (신텍스 슈가) 프로그래밍 언어가 편의상 축약식을 쓴것이다. 실체는 오브젝트 생성자 함수를 이용해서 만든것이다.

---

object()생성자 함수 : 빈객체를 만든다.

자바같은 타언어에 비하여 편리하고 유연하다.



빌트인 된 내장 기능이다. 오브젝트 생성자 함수는 뉴함수를 입력해야 한다

빈객체 이다.



이후에 동적으로 프로퍼티를 추가한다.

추가해야할 객체를 차후에 추가한다.

객체 리터럴은 오브젝트 함수를 편하게 사용하게 하기위해 만든 씬텍스 슈가이다.

자바스크립트에 빌트인 되어있다.

----



생성자 함수

객체를 만들기 위해서, 우리가 함수를 정의할 수 있다. 브젝트 생성자 함수는 기본적으로 빈 객체를 만든다. 커스터 마이징 함수 = 생성자 함수 자바에서 클래스 역할을 한다.



객체 리터럴은 하나만 만들때 사용한다

유사한 객체를 여러개 만들때는 생성자 함수를 사용하는게 바람직하다.



---

// 생성자 함수
function Person(name, gender) {
  this.name = name;
  this.gender = gender;
  this.sayHello = function(){
​    console.log('Hi! My name is ' + this.name);
  };
}

// 인스턴스의 생성
var person1 = new Person('Lee', 'male');
var person2 = new Person('Kim', 'female');

console.log('person1: ', typeof person1);
console.log('person2: ', typeof person2);
console.log('person1: ', person1);
console.log('person2: ', person2);

person1.sayHello();
person2.sayHello();



자바스크립트의 약점



함수의 정의입니다.

함수는 정의해두고 필요할때 호출해서 사용한다.

정의문일 뿐 , 정의 한 것을 호출하지 않으면 실행되지 않는다.





---

생성자 함수는객체를 만드는 것이 못ㄱ적이다

뉴 연산자와 함께 호출한다.

이 디스는 이 생성자함수가 생성할 객체를 의미한다.

두개이상 만들겠다는 사실이 기본 전제된다.



하나의 생성자 함수로 두개의 객체를 만든다. 



디스는 생성자 함수가 생성할 객체 자신이다.



디스는 필수불가결적 요소이다 

디스가 없다면 문법적으로 이상하다

디스를 바로 대체한다고 가정해도 



이후에 사용할 차후에 생성할 것을 일일이 지정해줘야 한다.



디스 =지시대명사 같은 요소



매개 변수 

펄슨 생성자 함수가 생성할 객체의 네임 프로퍼티의 네임을 할당한다.

인자로 문자가 매개변수로 이동된다. 프로퍼티의 동적으로 생성하면서 엘이이라는 값을 할당한다. 두번째 젠더 매일을 할당한닫

세번째 고정값을 호출한다.



틀은 유지하고 데이터만 변경하여 사용하는 방식이다. 





이또한 문제를가지고있다.



---

메모리를 보자

생성자 함수가 있다.

person () 객체를 생성한다. 

뉴 연산자와 함께 호출을 하면 객체를 만든다.

---

메소드는 참조값 주소를 가지고 있다.



---

오브젝트 생성자 함수를 사용할 일은 많지 않다.



객체 리터럴과 생성자 함수를 사용할 일이 대부분이다.



객체 리터럴과 생성자 함수의 사용 여부의 기준을 세우는 것은 쉽지 않다

일을 저질러서 실패를 통해 직감적으로 경험을 쌓아야 한다.

---

문법지식과 패턴지식을 쌓아서 실전의 과정을 겪으면서 



어려우면, 그것을 계속했을 때 가치가 올라간다.

어려우니까 배우는 것이다.

---

사람의 뇌

---

리터럴 함수는 객체 하나를 만들때 유리하다.

생성자 함수는 틀은 동일하고 데이터는 다른 것들을 생성해 낼때 유리하다.

---

어렵다는 이야기를 하지말자

---

ES6를 사용하면, this가 고민되지 않는다.

---

this는 생성자 함수가 생성할 함수를 가리키는 포인트 역할을 한다.

경우에 따라서 다른 것을 가리킨다(고정되어있지 않다.)

---

변수는 변수명으로 접속했다 프로퍼티는 프로퍼티명으로 접근한다. (프로퍼티는 소속이 있다)

---

프로퍼티 명은 문자임에도 불구하고 ''를 생략 할 수 있다.

First-name에 경우 - 연산을 하기 때문에 오류가 난다 그래서 ''를 붙여야 한다.



---

유사배열 객체

??

---

펑션은 예약어, 키워드로 쓰지 않는 것이 좋다.

## 3.2 프로퍼티 값 읽기

숫자가 허용되는 것 처럼 보이지만 사실은 문자이기 때문에 숫자에 접근할 때 '1' ,[1]로 사용한다.

## 3.3 프로퍼티 값 갱신 

값을 바꾸기위해서 접근한다. 변수 명을 가지고 , 재할당을 해야한다. 

매커니즘

기본자료형은 실제값을 갖고

그외에는 참조한다.

## 3.4 프로퍼티 동적생성

빈객체를 만들고 차후에 프로퍼티를 추가하고 할당하는 것을 동적생성이라고 한다.

---

일반 자료형과 객체가 있는 자료형을 컨트롤 하는 방법이다르다.



동적으로 크기가 변하는 애들은 힙에서 관리한다.

일반 자료형은 스택에서 관리한다.

## 3.5 프로퍼티 삭제

`delete` 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다.

실제로 사용하지 않는다, 사용하지 않으면 된다.



## 3.6 for-in문

es6 for-on문을 사용한다.

## 4. Pass by reference

사이드이펙트

부수효과 (선기능과 악기능이 있다.)



값을 가지고 있는 변수들을 상태값을 가지고 있다고 한다.

---

상태라는 단어를 사용하는 근본적인 이유는 ?

---

객체를 기본자료형처럼 사용하면 사이드이펙트(참조)가 발생하지 않는다.

---

사이드 이펙트를 없도록 만드는 것을 순수함수

사이드 이펙트가 있는것을 비순수함수라고한다

---

순수함수를 지양한다.

---

객체형을 기본자료형처럼 사용하는 것이다.

---

