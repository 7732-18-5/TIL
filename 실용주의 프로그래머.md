# 실용주의 프로그래머

#Program programming programmer

#The pragmatic programmer

> From journeymen to master

- rule
- maxim
- Intuition

```
초기에는 맥락에 상관없이 절대적으로 지킬 수 있는 규칙이 필요하다. 그러다가 발전을 하면 원리를 찾게 되고, 특정 맥락에서 격언을 이해, 응용하게 된다. 그리고 마지막에 이르러서는 이성보다는 직관에 따라 행동하게 된다. 
```

```차례
1장 실용주의 철학

2장 실용주의 접근법

3장 기본적인 도구

4장 실용주의 편집증 

5장 구부러지거나 부러지거나

6장 코딩하는 동안 해야 할 일들

7장 프로젝트 전에

8장 실용주의 프로젝트
```

```PREFACE
실용주의(pragmatic)라는 단어는 라틴어 pragmaticus(일에 숙달된)에서 나온 단어고, 그리스어 '~을 하다'라는 단어로부터 나온 단어다. 이책은 무엇을 '하는' 것에 대한 책이다.

프로그래밍은 기예(craft)다. 
프로그래밍이란 컴퓨터에게 사용자가 시키고 싶은 일을 하게 만드는 것이다.
프로그래머는 어떤 면으로는 들어주는 사람이고, 어떤 면으로는 조언하는 사람이며, 어떤 면으로는 통역하는 사람이기도 하고, 어떤 면으로는 명령을 내리는 사람이기도 하다. 또한 프로그래머는 애매모호한 요구사항을 포착해서 단순한 기계까지도 그것을 잘 수행 할 수 있도록 요구사항을 표현하는 방법을 찾으려 노력한다. 프로그래머는 다른 사람들이 이해 할 수 있도록 자신의 작업을 문서로 만들려고 노력하고, 다른 사람들이 자신이 한 것을 바탕으로 또 다른 것을 만들 수 있도록 자신의 작업을 설계하려고 노력한다.

프로그래머는 어떤 특정 기술에 매이면 안되며, 개별 상황마다 그 상황에서 좋은 해결방안을 고를 수 있도록 충분한 배경지식과 경험을 가져야 한다. 배경지식은 컴퓨터 과학의 기본 원리들을 이해하는 것에서 나오고 경험은 다양한 범위의 실제 프로젝트들을 수행해보는 것에서 나온다. 이론과 실천의 결합이 당신들을 강하게 만든다.

* 무엇이 실용주의 프로그래머를 만드는가?
얼리어뎁터 성향 새로운 것에 빨리 적응하는 성향
캐묻기를 좋아한
비판적인 사고의 소유자
현실적이다
다방면의 기술에 익숙하다.

실용주의 프로그래머가 되고 싶다면, 어떤 일을 하면서 자기가 무엇을 하고 있는지 생각하라고 말하고 싶다. 현재의 실천방법을 검토해보는 일회성 행사를 말하는 것이 아니다. 모든 개발 과정에서, 매일, 여러분이 내리는 모든 결정을 지속적이고 비판적으로 평가해보는 것이다. 절대 기계적으로 일하지 말라. 언제나 일하면서 동시에 자신의 일을 비평하고 분석하라. 오래된 IBM의 표어 '생각하라! THINK!'가 실용주의 프로그래머의 주문 Manta 이다.

혹시 책을 읽다가 전에 본 적 없는 단어와 마주치게 된다면 부탁하건데 그냥 건너뛰지 말라. 시간을 들여 웹이나 전산학 교과서등에서 찾아보라. 

기본 은어가 일반적으로 어떤 특정한 문제 도메인에 제한되어 있거나 어떤 특정한 개발 주기에 종속되어 있기 때문이다. 하지만 우리가 추천하는 기법들은 대부분 보편적으로 활용할 수 있다는 것이 이 책의 기본 철학 가운데 하나다. 

언어의 쇠퇴에 기여하라
```

```실용주의 프로그래머 TIP#1
자신의 기술 (Craft)에 관심과 애정을 가져라.
```

```실용주의 프로그래머 TIP#2
자신의 일에 대해 생각하면서 일하라.
```

#1 실용주의 철학

```1 실용주의 철학
실용주의 프로그래머는 무엇이 다른가? 우리는 태도와 스타일 그리고 문제와 해법에 접근하는 철학에 차이가 있다고 생각한다. 그들은 직면한 문제 너머를 생각하며, 문제를 항상 더 큰 맥락에 놓으려 노력하고, 항상 더 큰 그림을 보려 한다. 어쨋건 이런 더 큰 맥락 없이 도대체 어떻게 실용적일 수 있겠는가?

그들의 또 다른 성공의 열쇠는 자신이 하는 모든에 책임을 진다는 점이다.
대다수의 사람들은 때떄로 그럴듯한 이유로, 혹은 단지 과거의 관성 때문에 변화를 받아들이는 것이 어렵다고 느낀다. 

실용주의 철학은 실용주의 사고의 철학에서 뻗어나온다.
```

```1.1 고양이가 내 소스코드를 삼켰어요
실용주의 철학의 초석중 하나는 경력 향상, 프로젝트, 일상 업무의 면에서 자신과 자신의 행동에 대해 책임을 지는 것이다. 실용주의 프로그래머는 경력에 대해 책임을 지고, 자신의 무지나 실수를 인정하기를 두려워하지 않는다. 무지나 실수를 인정하는 일은 분명 프로그래밍에 있어 가장 즐거운 부분은 아니다. 실수나 무지 같은 단점에 대해서도 정직해져야 한다.
```

``` 실용주의 프로그래머 TIP#3
어설픈 변명을 만들지 말고 대안을 제시하라
```

```관련항목
프로토타입과 포스트잇 104p
리팩터링 291p
테스트하기 쉬운 코드 300p
유비쿼터스 자동화 361p
가차 없는 테스트 371p
```

```1.2 소프트웨어 엔트로피
소프트웨어 개발은 거의 모든 물리법칙에서 제외되지만, 엔트로피는 우리에게 많은 영향을 끼친다. 엔트로피는 시스템 내의 무질서한 정도를 가리키는 물리학 용어다. 소프트웨어의 무질서도가 증가할 때 프로그래머들은 이를 소프트웨어의 부패라고 일컫는다.
```

```실용주의 프로그래머 TIP#4
깨진 창문(나쁜 설계, 잘못된 결정, 혹은 형편없는 코드)을 내버려두지 말라.
```

```1.2 소프트웨어 엔트로피
나쁜 설계, 잘못된 결정, 혹은 형편없는 코드를 발견하자마자 바로 고쳐라. 불쾌한 코드를 주석처리하거나, 아직 구현되지 않았음(Not Implemented)이라는 메시지를 표시하거나, 가짜 dummy 데이터로 대치해 놓거나 하라.

같은 맥락에서, 코드가 청순할 정도로 아름다운(깨끗하고, 잘 설계되었으며 우아한) 프로젝트와 팀에 여러분이 속해 있다면, 아무도 아까 소방관들과 마찬가지로 별도의 주의를 기울여서 엉망으로 만들지 않도록 노력할 확률이 높다.
```

```관련항목
돌멩이 수프와 삶은 개구리 38p
리팩터링 291p
실용주의 353p
```
```1.3 돌멩이 수프와 삶은 개구리
무엇을 해야 하는지, 어떻게 해야 하는지 정확히 아는 상황이 있다. 전체 시스템이 눈앞에 그냥 드러난다. 여러분은 그 시스템이 옳다는 걸 안다. 하지만 일을 착수하려고 허락을 구하는 때부터, 뭔가 지연되거나 사람들이 멍한 눈으로 여러분을 바라본다. 위원회가 생길 테고, 예산 승인이 필요하고, 일들이 복잡해지기 시작한다. 모든 사람이 각자 자신의 자원을 지키려고 할 것이다. 때때로 이걸 '시작 피로 start-up fatigue'라고 부른다.
```

```실용주의 프로그래머 TIP#5
변화의 촉매가 되라
```

```1.3 돌멩이 수프와 삶은 개구리
깨진 창문 이론에서는 다른 누구도 주의를 기울이지 않는 다는 걸 알기에 사람들이 엔트로피에 대항해 싸울의지를 잃는다고 한다. 개인적으로 무엇을 하고 있는가에만 정신을 쏟지 말고, 주변에서 무슨 일이 벌어지는지 지속적으로 살펴보라. 
```

```실용주의 프로그래머 TIP#6
큰 그림을 기억하라
```

```관련항목
소프트웨어 엔트로피
우연에 맡기는 프로그래밍 273p
리팩터링 291p
요구사항의 구렁텅이 319p
실용주의 팀 353p
```

```Entropy
<물리> 열의 이동과 더불어 유효하게 이용할 수 있는 에너지의 감소 정도나 무효(無效) 에너지의 증가 정도를 나타내는 양.
<수학> 정보를 내보내는 근원의 불확실도를 나타내는 양.
<통신> 정보량의 기대치를 이르는 말. [비슷한 말] 평균 정보량.
```
```1.4 적당히 괜찮은 소프트웨어
우리는 종종 뭔가 나이게 하려다가 괜찮은 것마저 망친다.
- 리어왕 1.4

에드워드 요든 Edward Yourdon이 IEEE 적당히 괜찮은 사용자, 미래의 유지보수자 혹은 자기 마음의 평화를 유지하기에 적당히 괜찮은 소프트웨어를 만들도록 자신을 단련할 수 있다. 자신은 더 생상적이 되고 사용자는 한층 더 행복해 할 것이다. 여러분은 프로그램이 사실은 짧은 인큐베이션(incubation)기간에 비해 낫다는 걸 알게 될 것이다. '적당히 괜찮은'이라는 문구는 너절하거나 형편없는 코드를 의미하지 않는다. 시스템이 성공하려면 사용자의 요구사항을 충족해야 한다. 

단순히 프로그램에 새 기능을 추가하거나 코드를 한 번 더 다듬는다던가 하기 위해서 사용자의 요구사항을 무시하는 것은 전문가답지 못한 것이다. 우리는 허둥대라고 주창하는 것이 아니다. 불가능한 시간 약속을 하거나 데드라인에 맞추기 위해 기본적인 걸 빼버리거나 하는 것 역시 똑같이 전문가답지 못하다.

여러분이 만드는 시스템의 범위(scope)와 품질은 해당 시스템 요구사항의 일부로 명기되어야 한다.
```

```실용주의 프로그래머 TIP#7
품질을 요구사항으로 만들어라.
```

```1.4 적당히 괜찮은 소프트웨어
우리는 적당한 타협이 필요한 상황에 자주 처하게 된다. 놀랍게도 많은 사용자들은 멀티미디어 버전을 위해 일 년을 기다리느니 차라리 오늘 당장 좀 불편한 소프트웨어를 사용하고 싶어 한다.

완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 말라. 그냥 넘거가고 코드가 현재 상태에서 한동안은 그대로 있도록 놓아두라. 완벽하지 않을 수도 있다. 걱정하지 마라. 완벽해지기란 불가능하다.
```

```관련 항목
예광탄 96p
요구사항의 구렁텅이 319p
실용주의 팀 353p
위대한 유산 395p
```

```도전해 볼 것
사용자로서
1) 그들이 모든 버그를 제거할 때까지 기다리겠는가?
2) 복잡한 소프트웨어를 사용하면서 어느 정도의 버그는 감내하겠는가?
3) 결함이 더 적은 간단한 소프트웨어를 선택하겠는가?

모듈화가 소프트웨어 납품에 미치는 영향을 고려해보라.
모듈로 설계된 시스템을 만드는 것과 비교해, 거대한 덩어리 하나로 된 소프트웨어를 요구된 품질 수준으로 만드는 게 더 오래 걸릴까, 적게 걸릴까?
```

```1.5 지식 포트폴리오
지식에 대한 투자가 언제나 최고의 이윤을 낸다.
- 벤자민 프랭클린(Benjamin Franklin)

벤자민 프랭클린은 늘 뜻깊고  간결한 훈계를 한다. 말 그대로. 우리가 일찍 자고 일찍 일어나기만 한다면 위대한 프로그래머가 될 수 있을 텐데, 벤자민 프랭클린은 정말 정곡을 찌르는 말을 했다. 여러분의 지식과 경험이야말로 가장 중요한 전문가적인 자산이다. 
불행히도 그것들은 소진하는 자산(expiring assets)이다. 새로운 기술, 언어, 환경이 개발됨에 따라 지식은 옛것이 된다. 변화하는 시장 역시 여러분의 경험을 퇴물이나 별 소용없는 것으로 만들 수 있다. 여러분의 지식 가치가 점점 떨어짐에 따라, 회사나 클라이언트에 대한 여러분 자신의 가치 역시 떨어진다. 우리는 이런 일이 일어나는 걸 예방하고 싶다.

포토폴리오
1)주기적인 투자: 진지한 투자자들은 주기적으로 투자하는 습관이 있다.
금융 투자에서와 마찬가지로 자신의 지식 포트 폴리오에 주기적으로 투자해야 한다.

2)다각화: 장기간 성공의 열쇠를 다각화다.
여러가지를 알면 알수록 자신의 가치는 더욱 높아진다. 기본적으로 현재 작업에 사용하는 특정 기술의 등장과 퇴장을 알아야 한다. 하지만 거기서 멈추지 말라. 컴퓨터 분야의 지형은 빨리 변한다. 

3)리스크 관리: 똑똑한 투자자들은 자신의 포트폴리오를 보수적인 투자, 위험성이 큰 투자, 보상이 높은 투자 사이에서 균형을 잘 맞춘다.
위험하지만 잠재적으로 보상이 높은 것에서 리스크가 낮고 보상도 낮은 것에 이르기까지 기술은 다양한 스펙트럼 위에 존재한다.

4)싸게 사서 비싸게 팔기: 최대 수익을 위해 투자자들은 싸게 사서 비싸게 팔려고 한다.
새롭게 떠오르는 기술이 인기를 끌기 전에 미리 알고 학습하는 것은 저평가된 주식을 찾아내는 것만큼이나 어려울 수 있지만, 이익 또한 그만큼 클 수 있다.

5)검토 및 재조정: 포트폴리오는 주기적으로 재검토하고 재조정해야 한다.
이 산업 매우 동적이다. 
```

```실용주의 프로그래머 TIP#8
지식 포트폴리오에 주기적으로 투자하라.
```

```1.5 지식 포트폴리오
매년 새로운 언어를 최소 하나는 배워라.
: 다른 언어는 동일한 문제를 다르게 푼다. 몇 개의 서로 다른 접근법을 알면 사고를 확장하고 판에 박힌 사고에 갇히는 걸 예방하는 데에 도움이 된다. 409p

기술 서적을 분기마다 한 권씩 읽어라.
: 습관이 들면, 한달에 한권씩 읽어라 현재 사용하는 기술을 일단 완전히 익혔다면, 가지치기를 해서 지금 하는 프로젝트와 관련없는 분야까지 공부 범위를 넓혀라.

비 기술 서적도 읽어라.
: 방정식에서 인간이라는 변을 잊지 마라.

수업을 들어라. 
: 근처 대학, 혹은 시사회에서 열리는 흥미로운 강좌를 찾아보라.

지역 사용자 모임에 참여하라. 
: 고립은 경력에 치명적일 수 있다.

다른 환경에 실험해보라.
: 원도우에서만 일을 해왔다면, 집에서는 유닉스를 갖고 놀아보라.
ex)makefile, IDE

요즘 흐름을 놓치지 마라.
: 업계의 잡지와 기타 저널(403p), 여러분의 현재 브로젝트와 다른 기술을 다루는 것도 몇 개 선택하라.

인터넷을 이용하라. 
:새 언어 혹은 기타 기술에 대해 속속들이 알고 싶은가? 다른 사람이 그에 관해 어떤 경험을 했는지, 그들이 사용하는 특별한 전문용어가 어떤 뜻인지 등을 알아내는 데에는 뉴스그룹이 탁월하다. 논문, 상업 사이트 기타 여러분이 찾는 정보의 원천을 찾기 위해 웹서핑을 하라.

투자를 계속하는 것이 중요하다. 새로운 언어나 어떤 기술에 대해 익숙할 정도가 되면 다음으로 나아가라. 또 다른 것을 배워라. 이런 기술들을 프로젝트에서 사용하지 않거나 심지어 자신의 이력서에 올려놓지 않아도 상관없다. 학습 과정을 통해 사고를 확장하고 새로운 가능성과 새로운 방법들로 자신을 활짝 개방하게 될 것이다. 사고간의 교접(cross-polination)은 중요하다. 자신이 배운 교훈들을 현재 프로젝트에 적용하도록 노력하라. 프로젝트에서 그 기술을 사용하지 않을지라도 어쩌면 몇 가지 아이디어를 도입할 수 있을 것이다. 예컨대 객체지향에 익숙해지면 일반 C 프로그램도 다르게 작성하게 될 것이다.
```

```1.5 지식 포트폴리오
여러분이 엄청난 다독가이고, 해당 분야의 최신 발전에 대해 낱낱이 알고 있는데(쉬운 일이 아니다), 누군가 질문을 한다. 여러분은 답이 뭔지 전혀 알지못하고, 허물없이 그걸 인정한다. 거기에서 멈추지 마라. 답을 찾기 위한 개인적인 도전으로 생각하라.

1) 여러분이 뭘 묻고 싶어 하는지 정확히 알고, 가능하면 구체적이 되도록 하라.
2) 질문은 조심스럽고 예절바르게 써라. 여러분이 뭔가 부탁하는 입장이라는 사실을 기억하라. 답을 요구하고 있는 것이 아니다.
3) 질문을 썻으면 일단 답이 있는지 다시 한번 찾아보라. 키워드를 몇 개 뽑아서 웹을 검색해 보라. 
4) 공개적으로 물을지 개인적으로 물을지 정하라.
5) 물러서서 인내를 갖고 기다려라. 사람들은 바쁘기 때문에 구체적인 답을 얻을 때까지 며칠이 걸리기도 한다.

스스로 답을 찾지 못하겠거든, 누구 답을 찾아줄 수 있을지 그 사람을 찾아라. 중단하지 마라. 다른 사람들과 이야기함으로써 개인 네트워크를 구축하는데 도움이 되기도 하고, 답을 찾는 도중에 별로 관련이 없어 보이는 문제들에 대한 해답을 찾아서 놀라는 일도 생길 것이다.
이 모든 독서와 연구는 시간이 걸리고, 시간은 늘 부족한 자원이다. 그래서 미리 계획해야 할 필요가 있다. 할 일 없는 시간을 위해 늘 읽을거리를 준비하. 병원에서 진료를 기다리느라 허비되는 시간은 밀린 독서를 할 훌륭한 기회다.
```

```1.5 지식 포트폴리오
비판적 사고 
:마지막으로 중요한 점은 여러분이 읽거나 듣는 것에 대해 '비판적으로' 생각하는 것이다. 자신의 포트폴리오에 있는 지식이 정확하고, 벤더나 매체의 과대광고에 흔들림이 없도록 확실히 해야 할 필요가 있다. 자신의 도그마(dogma)가 유일한 답이라고 주장하는 열광자들을 주의하라. 상업주의의 힘을 절대 과소평가하지 마라. 단지 웹 검색 엔진에서 첫 머리에 나온 결과라고 해서 그것이 최선이라는 의미는 아니다. 콘텐트 제공자가 돈을 지불했을 수 있다. 서점에서 어떤 책을 특별하게 취급한다고 해서 그것이 좋은 책이라는, 혹은 심지어 인기 있는 책이라는 의미는 아니다. 누군가 좋은 자리를 차지하려고 돈을 지불했을 수 있다.
```

```실용주의 프로그래머 TIP#9
읽고 듣는 것을 비판적으로 분석하라.
```

```1.5 지식 포트폴리오
광범위한 포트폴리오 그리고 자신이 읽는 넘쳐나는 기술 출판물에 비판적 분석을 적용함으로써 복잡한 해답을 이해할 수 있을 것이다.

도전해 볼 것
:이번 주부터 새로운 언어를 배우기 시작하라. 
:새 책을 하나 읽기 시작하라. (하지만 이 책부터 우선 끝내라!) 만약 매우 상세한 구현과 코딩을 하고 있다면, 설계와 아키텍처에 관한 책을 한 권 읽어라. 고차원의 설계를 하고 있다면, 코딩 테크닉에 대한 책을 한 권 읽어라.
:프로젝트에 관여하지 않는 사람들은 혹은 자신과 같은 회사에 근무하지 않는 사람과 기술에 관한 대화를 하라.
```
```1.6 소통하라
나는 무시당하느니 차라리 샅샅이 훑어 보는 시선이 낫다고 봐요.
- 메이 웨스트
최고의 아이디어, 최상의 코드 혹은 가장 실용주의적인 사고 등이 있다고 해도 다른 사람들과 소통할 수 없다면 그것들은 궁극적으로 아무 효용이 없다. 효과적인 소통 없이는 어떤 훌륭한 아이디어도 고아에 지나지 않는다. 

말하고 싶은게 무언지 알아라
:의사소통에서 가장 어려운 부분은 아마도 여러분이 말하고자 하는 것이 정확히 무엇인지 생각해 내는 것이다. 
무엇을 말할지 미리 계획하라. 개요를 작성하라  그리고 자문하라. "이게 내가 말하고자 하는 것을 잘 전달하는가?" 그렇게 될 때 까지 다듬어라. 문서 작성뿐 아니라, 중요한 회의나 전화통화에 직면 했을 때, 의사소통하고 싶은 아이디어들을 적은 다음, 제대로 전달하기 위해 필요한 전략을 몇 개 세워라.

청중을 알아라.
:정보를 전달하고 있는 경우에만 소통하고 있다고 말할 수 있다. 그렇게 하기위해서는 청중의 요구와 관심, 능력을 이해할 필요가 있다. 우리는 전형적인 개발자가 어떤 난해한 기술의 장점에 대해 긴 독백을 읊조리는 동안, 앉아 있는 마케팅 부사장으 ㅣ눈이 점점 흐리멍텅해지는 회의에 참석해 봤다. 이것은 소통이 아니다. 단지 지껄임일 뿐. 짜증나는 일이다.
청중에 대한 뚜렷한 그림을 가져야 한다.
```

```WISDOM 청중 이해하기
1)무엇(what)을 배우길 원하는가?
2)말하려는 것에서 그들의 관심(interest) 있어 하는 건 무엇인가?
3)얼마나 소양(sophisticated)이 있는가?
4)어느정도 구체적인 내용(detail)을 원하는가?
5)누가 정보를 소유(owe)하길 원하는가?
6)그들이 경청하도록 동기(motive)를 주려면 어떻게 해야 할까?
```
```1.6 소통하라
때를 골라라
:청중이 무엇을 듣기 원하는지 이해하기 위해서는 , 그들의 우선순위를 알아야 한다.
가끔 '~에 대해서 이야기할 좋은 때일까?'라는 간단한 질문을 해보는 것만으로도 충분하다.

스타일 골라라 
:전달하는 스타일이 청중에 어울리도록 조정하라. 어떤 사람들은 좀 격식 있는 '그저 사실만 전달하는' 브리핑을 원한다. 다른 사람들은 본론에 들어가기 전에 길고 폭넓은 한담을 원한다. 다른 사람들은 본론에 들어가기 전에 길고 폭넓은 한담을 원한다. 어떤 이는 두꺼운 문서로 보고 받길 좋아하는 반면, 다른 이는 간단한 메모나 이메일을 기대한다. 뭐가 좋을지 모르겠거든 물어보라.

하지만 여러분이 의사소통의 나머지 반쪽이라는 사실을 기억하라. 누군가가 뭔가를 간명해달라고 말하는데, 그 설명을 대여섯 장 이하로 줄일 수 있는 방법이 없다는 생각이 들면,  사실이 그렇다고 말하라. 이런 종류의 피드백 역시 의사소통의 한 가지 형태임을 기억하라.

멋져 보이게 하라
:여러분의 아이디어는 중요하다. 청중에게 전달하기 위한 멋있는 매개물이 필요하다. 
많은 개발자들(그리고 그들의 관리자들)은 문서를 만들 때에 내용에만 집중한다. 우리는 이것이 실수라고 생각한다. 

청중을 참여시켜라
:가능하다면 문서 초고에 독자가 참여하도록 하라. 피드백을 받고, 그들의 머릿속을 도용하라. 더 좋은 관계를 형성하게 될 것이고, 아마도 그 과정에서 더 나은 문서를 만들게 될 것이다.

청자(listener)가 되어라
:다른 사람들이 여러분이 하는 말을 경청해주길 바란다면 사용할 수 있는 기법이 하나 있다. 바로 경청하는 것이다. 모든 정보를 갖고 있는 사람이 여러분인 경우에도, 심지어 20명의 중역 앞에 서서 격식있는 회의를 진행하는 경우에도 사람들이 하는 말을 귀기울여 듣지 않는다면, 그들 역시 여러분의 말을 귀기울여 듣지 않을 것이다.

응답하라
: 누군가가 질문을 했는데 아무런 응답이 없다면 그가 무례하다고 느낄 것이다. 하지만 여러분 자신도 사람들이 정보를 요청하거나 어떤 행동을 부탁하는 이메일 혹은 메모를 보냈을 때, 얼마나 자주 응답하는가? 하루하루 바쁜 삶 속에서 잊어버리고 살기 쉬운 일이다. 심지어 응답이 단순히 "다음에 답해 드리겠습니다."라고 할지라도 언제나 이메일과 음성 메일에 답을 하도록 하라. 늘 사람들에게 응답을 해주면 때때로 일어나는 실수에 대해 훨씬 더 관대해질 것이고, 여러분이 그 사항을 아직 잊지 않았다는 느낌을 줄 것이다.

진공속에서 작업하지 않는 이상 우리는 의사소통을 해야 한다. 그 소통이 더 효과적일수록 좀 더 많은 영향력을 갖게 될 것이다.
```
```실용주의 프로그래머 TIP#10
무엇을 말하는가와 어떻게 말하는가 모두 중요하다.
```

```관련항목
관련항목
프로토타입과 포스트잇 104p
실용주의 팀 353p
```

# 2 실용주의 접근법

```2.실용주의 접근법
소프트웨어 개발의 모든 차원에 적용가능한 팁과 요령이 있고, 거의 공리와 같은 아이디어들이나 사실상 보편화된 프로세스들이 있다. 
1)중복의 해약
:시스템을 통틀어 어떤 지식을 중복하지 말라고 경고한다.
2)직교성 Orthogonality
:하나의 지식을 여러개의 시스템 컴포넌트에 걸쳐 쪼개 놓지 말라고 조언한다.
3)가역성 Reversibility
:변화하는 환경에서 프로젝트를 분리하는 몇 가지 기법을 볼 것이다.
4)예광탄 Tracer Bullets
:요구사항을 모으고 설계를 테스트하고 코드를 구현하는 것을 동시에 가능케하는 개발스타일
프로토타입과 포스트 잇
:아키텍처,알고리즘, 인터페이스, 아이디어등을 테스트하기 위해 프로토 타입을 어떻게 사용하는지
5)추정 Estimating
마지막으로 우리는 시간과 자원이 한정된 세상에서 일한다. 어떤 일들이 얼마나 걸릴지 아는데 능숙해진다면 이런 희소성을 더 잘 극복 할 수 있다. 

개발 중에 이런 기본적인 원리들을 유념한다면 더 좋고, 더 빠르고, 더 강력한 코드를 작성 할 수 있을 것이다.
```

```
만약 당신이 천재가 양성될 수 있는 것이라고 생각한다면 수천 명의 잠재적 천재가 인정을 받지 못한 채 사라진 것은 비극이다.

-대린 맥마혼
```

```2.7 중복의 해악
프로그래머로서 우리는 지식을 수집하고, 조직하고, 유지하고, 통제한다.
우리는 명세서의 지식을 문서화하고 실행 코드에서 그 지식이 생명을 갖고 살아나도록 한다.
불행이도 지식은 고정적이지 않다. 그것은 변화한다. 종종 급격하게 말이다. 
대부분의 사람들은 유지보수가 버그를 고치고 기능을 개선하는 것을 의미하기 때문에, 애플리케이션이 출시되었을 때 비로소 유지보수가 시작된다고 믿는다. 우리는 이들이 틀렸다고 생각한다. 프로그래머들은 늘 유지보수 모드에 있다. 우리가 이해하고 있는 것은 날마다 바뀐다. 설계를 하거나 코딩을 하는 중에 새로운 요구사항이 바뀐다. 어쩌면 환경이 변할 수도 있다. 이유가 무엇이건 간에, 유지보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.
소프트웨어를 신뢰성 높게 개발하고, 유지보수하기 쉽게 만드는 것을 DRY원칙이라고 한다.
모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야한다.
```

```실용주의 프로그래머 TIP#11
반복하지마라 Don't Repeat Yourself
```

```2.7 중복의 해악
어떻게 중복이 생기는가?
1)강요된impose 중복 
:개발자들은 다른 선택이 없다고 느낀다. 환경이 중복을 요구하는 것처럼 보인다.

a) 정보의 다양한 표현양식
b) 코드내의 문서화
:프로그래머는 자신의 코드에 주석을 달도록 교육받는다. 훌륭한 코드에는 주석이 많다고 배운다. 불행히도 그들은 코드에 왜 주석이 필요한지 배우지 않는다. 나쁜 코드야말로 많은 주석을 필요로 한다. DRY 원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔주고, 주석은 다른 높은 차원의 설명을 위해 아껴두라고 말한다. 그렇지 않으면 지식을 중복하게 되며, 변경할 때마다 배번 코드와 주석 모두를 바꾸어야 한다.
c) 문서화와 코드
:문서를 작성하고 나서 코드를 작성한다. 문서와 코드 모두는 동일 지식에 대한 표현이다.

*)언어에 관한 문제
:많은 언어가 소스코드에 상당한 양의 중복을 강요한다. 이것은 언어가 모듈의 인터페이스와 그 구현을 분리하는 경우가 자주 생긴다.

2)부주의한 중복
:개발자들은 자신들이 정보를 중복하고 있다는 것을 깨닫지 못한다.
때때로 중복은 설계 실수의 결과로 나타나기도 한다.
복수의 상호의존적 데이터 요소들이 있을 경우 생기는, 약간은 덜 분명한 종류의 비정규화된 데이터가 있다. 정규화하라.
개발 과정에서 나중에는 성능상의 이유로 DRY원칙을 위배할 수도 있다. 이것은 비용이 많이 드는 연산을 피하기 위해 데이터를 캐싱해야 하는 경우 종종 발생한다. 요령은 그 영향을 국소화하는 것이다. 가능한 곳에서는 객체의 속성을 읽고 쓸 수 있는 액세스 함수를 사용하라. 

3)참을성 없는 중복
:중복이 쉬워 보이는 때문에 개발자들이 게을러져서 중복을 하게 된다.
모든 프로젝트는 시간의 압박을 받는다. 우리가 할 수 있는 최선이란 결국 지름길을 택하는 것이라고 내모는 그런 압박 말이다. 만약 이런 유혹을 느낀다면 '돌아가는 길이 지름길이다' 라는 진부한 격언을 기억하라.
지금 당장 몇 초를 절약할 수 있을지라도, 나중에는 몇 시간을 잃게 될런지 모른다. 참을성 없는 중복은 발견하기도 쉽고 다루기도 쉬운 형태지만, 나중의 고통을 피하기 위해서는 훈련이 필요하고, 미연에 시간을 투자할 의지가 있어야 한다.
4)개발자간의 중복
:한 팀에 있는 여러 사람들이 동일한 정보를 중복한다.
높은 차원의 해법으로, 깨끗한 설계와 강력하고 기술적인 프로젝트 리더, 그리고 설께 내에서 책임의 분배가 제대로 이해되도록 하는 것이 있다.
분명한 책임 영역으로 나누어지지 않는 공통 필요 기능이나 데이터는 여러 번 거듭 구현될 가능성이 있다. 최선책은 개발자간에 적극적이고 빈번한 소통을 장려하는 것이다.
```
```실용주의 프로그래머 TIP#12
재사용하기 쉽게 만들라.
```

```2.8 직교성
설계, 빌드, 테스트 그리고 확장하기에 쉬운 시스템을 만드는 데에 있어 직교성 Orthogonality 은 매우 중요한 개념이다. 종종 직교성은 여러분이 배우는 여러 다른 방법론과 기법이 잠재되어 있다. 이것은 실수다. 직교성의 원칙을 적용하는 걸 직접 배우게 되면 여러분이 만드는 시스템의 질을 즉각 개선할 수 있을 것이다.

'직교성'은 기하학에서 빌려온 용어다. 그래프의 축과 같이 두 직선이 직각으로 만나는 경우 직교한다고 말한다. 벡터의 입장에서 보면, 두개의 선은 '독립적'이다. 두 선 가운데  하나의 방향으로 움직여도 나머지 선 위로 투영된 여러분의 위치는 변하지 않는다. 

컴퓨터에서 이 용어는 독립성 independence이나, 결합도 줄이기 decoupling 를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다. 잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스에 대해 직교할 것이다. 

데이터베이스에 영향을 주지 않으면서 인터페이스를 바꿀 수 있고, 또한 인터페이스를 바꾸지 않으면서 데이터베이스를 교환할 수 있다.

직교성의 장점
:비직교적인 시스템은 본질적으로 변화와 조정을 하기가 복잡하다. 시스템의 컴포넌트들이 고도로 상호의존적인 경우, 특정 국지적 부분만 수정하는 방법이란 없다.

우리는 자족적 self-contained인 컴포넌트를 설계하기 원한다. 독립적이며, 단일하고 잘 정의된 목적을 가진 컴포넌트
해당 컴포넌트들은 각기 격리되어 있다. 외부 인터페이스를 바꾸지 않는 한, 전체 시스템으로 퍼져나가는 문제를 일으키지 않는다.

직교적인 시스템을 작성하면 두 가지의 큰 장점이 있다. 생산성 향상과 리스크 감소
```

```실용주의 프로그래머 TIP#13
관련 없는 것들 간에 서로 영향이 없도록 하라.
```

```2.8 직교성
1)생산성 향상
:변화가 국소화 localize되서 개발 시간과 테스트 시간이 줄어든다. 상대적으로 작고, 자족적인 컴포넌트를 작성하는 것이 하나의 커다란 코드 덩어리를 만드는 것보다 더 쉽다. 새로운 코드를 추가할 때 마다 기존의 코드를 계속 바꾸어야할 필요가 없다.

:직교적인 접근법은 또한 재사용을 촉진한다. 컴포넌트들에 명확하고 잘 정의된 책임이 할당되어 있다면 애초의 구현자들이 미처 생각하지 못했던 방식으로 새로운 컴포넌트와 결합할 수 있다. 시스템이 더 느슨하게 결합coupling되어 있을수록 재설정reconfigure하고 리엔지니어링하기 쉽다.

:직교적인 컴포넌트들을 결합하는 경우 꽤 미묘한 생산성 향상이 있다.
직교적인 컴포넌트들을 결합함으로써 단위 노력당 더 많은 기능을 얻을 수 있다.

2)리스크 감사
:직교적인 접근법은 어떤 개발에도 내재하는 리스크들을 감소시켜 준다.
:감염된 코드는 격리된다.
:시스템이 잘 깨어지지 않는다.
:직교적인 시스템은 해당 컴포넌트들에 대해 테스트를 설계하고 실행하기 훨씬 쉽기 때문에, 아무래도 더 많은 테스트를 하게된다.
:써드파티 컴포넌트로 연결되는 인터페이스들이 전체 개발의 작은 부분에 한정되기 때문에 특정 벤더나 제품, 플랫폼에 덜 종속 될 것이다.
```

```2.8 직교성
프로젝트 팀
:프로젝트 팀, 이것은 종종 직교성의 문제다. 어떻게 팀을 조직해서 책임이 잘 정의되어 있고 중복이 최소화 된 그룹으로 만들 것인가?

:우리는 애플리케이션에서 인프라infrastructure를 잘 분리하는 방식을 선호한다. 주된 인프라 컴포넌트 (데이터베이스, 커뮤니케이션 인터페이스, 미들웨어 레이어)마다 서브팀을 할당한다. 

:프로젝트 팀 구조가 얼마나 직교성을 갖는지 간단히 측정해 볼 수 있는 방법이 있다. 요청된 개별 변화에 대한 토론에 참여할 필요가 있는 사람이 몇명인가를 보라. 숫자가 클수록 그룹의 직교성은 낮다. (이와 동시에 서브팀들끼리 지속적으로 의사소통할 것을 장려한다.)

설계
:개발자 대다수는 직교적인 시스템을 설계할 필요를 잘 안다. 그런 설계과정을 설명할 때 모듈라modular, 컴포넌트 기반, 레이어 같은 다른 용어를 사용하기도 한다. 시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 때로는 이런 컴포넌트들이 레이어로 조직되기도 하는데, 각 레이어는 하나의 추상화 층을 이루게 된다. 이 레이어식 접근은 직교적인 시스템을 설계하는 강력한 바업ㅂ이다. 각 레이어는 자기 밑에 있는 레이어들이 제공하는 추상화만 사용하기 때문에, 코드에 영향을 끼치지 않으면서 아래에 있는 다른 구현들을 바꾸는 높은 유연성을 얻을 수 있다. 
또한 모듈같에 종속성이 빨리 늘어나는 위험을 감소히킨다. 

:직교적인 설계를 테스트하는 손쉬운 방법이 있다. '특정 기능에 대한 요구사항을 극적으로 변경했을 경우, 몇개의 모듈이 영향을 받는가?' 직교적인 시스템에서는 답이 하나여야 한다.

:자신의 힘으로 제어할 수 없는 속성에 의존하지 마라.

툴킷과 라이브러리
:써드파티 툴킷이나 라이브러리를 도입할 때, 시스템의 직교성을 보존할 수 있는지 주의 깊게 살펴보고 기술을 현명하게 선택하라.

코딩
:코드를 작성하고 있다면 언제나 애플리케이션의 직교성을 떨어뜨릴 수 있는 위험에 노출되어 있다.

코드의 결합도를 줄여라.
:즉 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라.

전역데이터를 피하라.
:코드가 전역 데이터를 참조할 때마다, 코드는 해당 데이터를 공유하는  다른 컴포넌트와 묶이게 된다. 

유사한 함수를 피하라.
: 종종 유사해 보이는 함수의 집합을 구현해야 할 때가 있다. 아마도 시작과 끝에서는 공통 코드를 공유하지만 중간의 알고리즘이 다를 것이다. 중복 코드는 구조적 문제의 징후다. 

자신이 작성하는 코드를 항상 비판적으로 검토해 보는 습관을 기르기 바란다. 기회가 있을 때마다 코드의 구조와 직교성을 향상시키기 위해 노력하라. 

테스트
:교적으로 설계, 구현한 시스템은 테스트하기 더 쉽다. 시스템 컴포넌트 간의 상호작용이 형식화되고 제한되었기 때문에 시스템 테스트의 더 많은 부분을 각각의 모듈 수준에서 수행 할 수 있기 때문이다.

문서화
:직교성은 문서에도 적용할 수 있다. 내용과 표현이 두 축이 된다. 정말 직교적인 문서라면 내용 변화 없이 표현을 극적으로 바꿀 수 있을 것이다.

직교적으로 살아가기
:DRY 원리는 시스템 내부의 중복을 최소화시키고, 직교성은 시스템 컴포넌트 간의 상호의존도를 줄인다. 개발하고 있는 시스템이 더 우연하고, 이해하기 쉽고 또한 디버그, 테스트, 유지도쉬워질 것이다.
```

```가역성
당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다.
에밀 사르티에 Emil-Auguste Chartier [종교론]

가역성
:이 책의 많은 주제들은 유연하고, 적응 가능한 소프트웨어를 만드는 방법에 대해 설명한다. DRY 원리, 결합도 줄이기, 메타데이터 사용하기를 따른다면 중요하면서도 되돌릴수 없는 결정을 가능한 한 줄일 수 있게 될 것이다. 이는 우리가 프로젝트 초기에 항상 최선의 결정을 내리 것은 아니라는 점에서 매우 유용하다.

결정이 돌에 새겨지는 것이라 가정하고, 발생할지도 모를 우연한 사건들에 대해 준비하지 않는 데에서 실수가 나온다. 결정이 돌에 새겨진 것이 아니라 해변가의 모래 위에 쓰인 글씨라 생각해 보자. 언제든지 큰 파도가 글씨를 지워버릴 수 있다.

유연한 아키텍처
:많은 사람들이 코드를 유연하게 유지하려고 노력한다. 하지만 아키텍처, 배포, 벤더 통합 여역의 유연성에 대해서도 관심을 기울일 필요가 있다.
```
```실용주의 프로그래머 TIP#14
최종 결정이란 없다.
```

```예광탄
새로운 프로젝트에서도 이 사실은 마찬가지다. 전에 만들어진 적이 없는 전혀 새로운 것을 만들고 있다면 더욱 그렇다. 사용자들이 이전에 그런 시스템을 한 번도 본 적이 없기 때문에 요구사항이 막연할지도 모른다. 익숙하지 않은 알고리즘, 기술, 언어, 라이브러리들을 사용해야 할지 모르므로, 여러분은 수 많은 미지의 것과 맞닥뜨리게 된다.
시스템을 돌아갈 때까지 세세히 명세화 하는 것이 이런 상황에서의 전형적인 반응이다. 하지만 실용주의 프로그래머는 예광탄 사용을 선호한다.
코딩에서도 동일한 효과를 얻으려면, 우리를 요구사항으로부터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달하게 해줄 무언가를 찾아야 한다.
```

```실용주의 프로그래머 TIP#15
목표물을 찾기 위해 예광탄을 써라.
```

```예광탄
예광탄 코드는 나중에 버리려고 만드는 것이 아니다. 예광탄 코드에도 상용 코드와 마찬가지로 모든 에러 검사, 구조화, 문서화, 자기 검사가 포함된다. 단지 예광탄 코드에는 아직 완전한 기능이 들어있지 않을 뿐이다. 하지만 시스템을 구성하는 요소를 모두 연결해 놓은 후라면 목표물에 얼마나 가까이 다가섰는지 확인할 수 있으며, 필요하다면 조정도 할 수 있다. 그렇게 해서 일단 목표물을 맞춘다면 기능을 추가하는 일은 쉽다.

이와 대비되는 전형적인 방법은 일종의 거대 공학적 접근 방식이다. 모드는 모듈들로 분류되고, 각 모듈은 진공 상태에서 작성된다. 모듈을 조립해서 시스템의 하위 부품을 만들고 다시 조립해서 언젠가 전체 애플리케이션이 완성된다. 이때가 되어서야 전체 애플리케이션을 사용자에게 보여주거나 테스트할 수 있다. 

예광탄 코드 접근 방법에 여러 장점
1. 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.
:여러분이 하는 일이 정확히 무엇인지 전달하는데 성공했다면, 사용자들은 지금 보는 것이 아직 완성되지 않은 것임을 이해할 것이다. 이들은 기능이 없다고 실망하지 않을 것이다. 오히려 자기가 쓸 시스템에 눈에 보이는 진전이 있음을 보게 되어 매우 기뻐할 것이다.
2. 개발자들은 들어가서 일할 수 있는 구조를 얻는다. 
:아무것도 쓰여 있지 않는 백지가 가장 채우기 힘든 종이다. 일단 애플리케이션의 모든 요소간 상호작용을 다 만들어 코드로 구체화까지 해놓은 후라면, 여러분의 팀은 더 이상 무에서부터 많은 것을 만들어 낼 필요가 없어진다. 모든 사람의 생산성이 더 좋아지고, 일관성도 촉진된다.
3. 통합 작업을 수행할 기반이 생긴다.
:시스템의 요소들이 모두 연결된 다음에는, 코드를 추가 할 수 있는 어떤 환경이 생긴다. 새로 도입된 변화가 어떤 영향을 주는지는 더욱 명확하게 보이며, 상호작용들은 더 제한적이다. 그러므로 디버깅과 테스팅 속도도 빨아지고 더 정확해 질 것이다.
4. 보여줄 것이 생긴다. 
:프로젝트 후원자들과 고위층 인사들은 가장 껄끄러운 시간에 데모를 보고 싶어하는 경향을 보인다. 
5. 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.
:개발 단위가 작기 떄문에, 몇주가 지나도 언제나 95% 완성이라고 보고되는 코드 덩어리들이 생기는 상황을 피할 수 있다.

예광탄이 언제나 목표물을 맞추는 것은 아니다.
:예광탄코드 기법은 일이 어떻게 될지 100% 확신할 수 없는 상황에서 사용된다. 지금 있는 것을 목표물에 가까이 가져 가려면 어떻게 바꾸어야 할지 생각해내고, 가벼운 개발 방법론을 선택했다는 사실에 감사하라. 코드의 크기가 작으면 관성 역시 약하므로 빠르고 쉽게 바꿀 수 있다. 다른 어떤 방법보다 더 적은 비용과 더 빠른 속도로 애플리케이션에 대한 반응들을 모아서 새롭고 더 정확한 버전을 만들 수 있을 것이다. 그리고 애플리케이션의 모든 중요 요소들이 예광탄 코드에도 들어가 있기 떄문에, 사용자들은 지금 보고 있는 것이 단지 종이에 쓰인 명세가 아니라 현실에 기반을 두고 있다는 확신을 가질 수 있다.

예광탄 vs 프로토타이핑
:아마 예광탄 코드라는 개념은 좀 더 공격적인 이름이 붙었을 뿐 프로토 타이핑과 다를 바 없다고 생각하는 사람도 있을 것이다. 그러나 다른 점이 있다. 프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 진짜 프토토타입 방식을 따른다면, 어떤 개념을 구현해 보려고 시도할 때 대충 끼워 맞춘 것들을 모두 버린 다음, 실험 과정에서 얻은 교훈을 바탕으로 다시 코드를 만들게 된다.

:사용자 인터페이스는 직관적이어야하며, 최적의 방법이 어떤 것인지 결정하는 알고리즘을 매우 복잡하다.

:기능 테스트는 아마 고차원의, 사용하기 쉬운 언어로 코드를 작성하겠지만, 저차원의 성능 테스트라면 기계어에 가까운 다른 언어로 코드를 작성할 것이다. 어떤 경우든 일단 결정을 내린 후라면, 다시 처음부터 시작해서 현실 세계와 상호작용하는 최종 환경에서 알고리즘을 코드로 작성한다. 바로 이것이 프로토타이핑이고 매우 유용한 방법이다.

프로토타입은 나중에 버릴 수 있는 코드를 만든다. 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다. 프로토타입을 예광탄이 하나라도 발사되기 전에 먼저 일어나는 정찰과 정보 숫집으로 생각하면 되겠다.
```
```프로토타입과 포스트잇
소프트웨어 프로토타입은 위험 요소를 분석하고 노출시키며 이를 매우 저렴한 비용으로 바로 잡을 기회를 얻기 위해 만든다.
프로토타입은 반드시 코드로 작성해야 한다고 생각하는 사람도 있지만, 꼭 그럴 필요는 없다. 포스트잇은 작업흐름과 애플리케이션 로직과 같은 동적인 것들을 프로토타이핑 해 볼 수 있는 훌륭한 도구다. 사용자 인터페이스는 화이트보드에 그려 보거나, 페인트 프로그램, 인터페이스 빌더 등을 이용해 기능은 구현하지 않고 인터페이스만 그려보는 방법으로 프로토타입을 만들 수 있다.

프로토타입은 제한된 몇 가지 질문에 답할 목적으로 설계되기 때문에 실제 제품보다 훨씬 적은 비용으로 빠르게 개발 할 수 있다. 앞으로 사용자에게는 매우 중요해질지도 모르지만 현재는 중요하지 않은 세부사항 등을 코드에서 무시 할 수 있다.
하지만 만약 세부사항을 포기할 수 없는 환경에 처해있다면, 이런 경우에는 예광탄 스타일의 개발이 더 적절 할 것이다.

프로토타입의 대상
:아키텍처
:기존 시스템에 추가할 새로운 기능
:외부 데이터의 구조 혹은 내용
:써드파티 도구나 컴포넌트
:성능문제
:사용자 인터페이스 설계
프로토타이핑은 학습 경험이다. 프로토타입의 가치는 생성된 코드에 있는 것이 아니라 이를 통해 배우게 되는 교훈에 있다. 이것이 프로토 타이핑의 진정한 핵심이다.
```

```실용주의 프로그래머 TIP#16
프로토타입을 통해 학습하라.
```

```
프로토타입을 어떻게 사용할 것인가?
정확성: 적절히 가짜 데이터를 사용할 수 있다.
완전성: 프로토타입은 어쩌면 미리 선정한 입력 데이터와 한가지 메뉴 항목에서만 작동하면 되기 때문에 제한된 기능만을 제공하기도 한다.
안정성: 에러 검사는 불완전 할 수도 있고, 때론 무시될 수도 있다. 
스타일: 프로토타입 코드는 주석이나 문서를 많이 만들지 않아도 된다.

아키텍쳐 프로토타이핑

```